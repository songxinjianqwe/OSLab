#include <stdio.h>#include <stdbool.h>#include <string.h>#include <ctype.h>#include <malloc.h>#include <stdlib.h>typedef unsigned char u8; //1 bytetypedef unsigned short u16;//2 bytestypedef unsigned int u32; // 4 bytes#pragma pack (1)#define MAX_STACK_SIZE 120//**********************************************************************************************************************************struct ClusterInfo {    char fileName[12];    int clusterIndex;    int level;};struct Stack {    struct ClusterInfo clusters[MAX_STACK_SIZE];    int top;//pointer , points to head node of queue};void initStack(struct Stack *stackPtr) {    stackPtr->top = -1;}void push(struct Stack *stackPtr, struct ClusterInfo info) {    stackPtr->clusters[++stackPtr->top] = info;}bool isEmpty(struct Stack *stackPtr) {    return stackPtr->top == -1;}struct ClusterInfo pop(struct Stack *stackPtr) {    if (isEmpty(stackPtr)) {        abort();    }    struct ClusterInfo info = stackPtr->clusters[stackPtr->top];    stackPtr->top--;    return info;}//***************************************************************************************************************************const int NORMAL_COLOR = 0;const int FILE_COLOR = 1;const int DIR_COLOR = 2;/** * use nasm to print string * @param color * @param str */void print(int color,char * str);/** * use nasm to print number * @param color * @param number */void printNumber(int color ,int number);int searchSubDirectory(FILE *file, int firstLogicalCluster, char *targetFileName);int countSubDirectory(FILE *file, int firstLogicalCluster, struct Stack *stackPtr, char *parentDirName);bool traverseSubDirectory(FILE *file, char *directoryName, int firstLogicalCluster, char *targetFileName);long getBeginIndexOfCluster(int firstLogicalCluster);//*****************************************************************************************************************************//**********************************************************************************************************************************/** * The data from the 11th byte of boot sector will be loaded into bootSector * 13 bytes */struct BootSector {    u16 bytesPerSector;//bytes per sector 512    u8 sectorsPerCluster; //sectors per cluster 1    u16 bootReservedSectors;//number of boot's reserved sectors 1    u8 FATs;//number of FATs 2    u16 maxRootDirEntries;//maximum number of root directory entries    u16 totalSectors; //total sector count    u8 ignore;    u16 sectorsPerFAT;//sectors per FAT  9};const int DIRECTORY_ENTRY_SIZE = 32;const int DIRECTORY_ENTRY_NUMBER_PER_SECTOR = 16;/** * Directory Entry * 32 bytes */struct DirectoryEntry {    char fileName[11];//fileName+extension    u8 attribute;//attribute of this file    u16 reserved;    u16 createTime;    u16 createDate;    u16 lastAccessDate;    u16 ignore;    u16 lastWriteTime;    u16 lastWriteDate;    /**     * file points to the logical cluster,the value is the index of FAT     * Physical cluster index = 33 + logical cluster - 2     */    u16 firstLogicalCluster;    u32 fileSize;};//important global variables/** * bytes per sector */u16 bytesPerSector;/** * sectors per cluster */u8 sectorsPerCluster;/** * boot reserved sectors */u16 bootReservedSectors;/** * FATs */u8 FATs;/** * sectors per FAT */u16 sectorsPerFAT;/** * maximum number of root directory entries */u16 maxRootDirEntries;//**********************************************************************************************************************************/** * read the boot sector into struct BootSector * @param file * @param bootSectorPtr */void readBootSector(FILE *file, struct BootSector *bootSectorPtr) {    fseek(file, 11, SEEK_SET);    fread(bootSectorPtr, 1, sizeof(struct BootSector), file);//read 13 bytes from 11th bytes}/** * initialize the important global variables * @param bootSectorPtr */void initGlobalVariable(struct BootSector *bootSectorPtr) {    bytesPerSector = bootSectorPtr->bytesPerSector;    sectorsPerCluster = bootSectorPtr->sectorsPerCluster;    bootReservedSectors = bootSectorPtr->bootReservedSectors;    FATs = bootSectorPtr->FATs;    sectorsPerFAT = bootSectorPtr->sectorsPerFAT;    maxRootDirEntries = bootSectorPtr->maxRootDirEntries;}/** * see if this filename contains illegal characters * @param fileName * @return */bool isIllegalFileName(char *fileName) {    for (int i = 0; i < 11; ++i) {        if ((fileName[i] >= 0x30 && fileName[i] <= 0x39) || (fileName[i] >= 0x41 && fileName[i] <= 0x5a) ||            (fileName[i] >= 0x61 && fileName[i] <= 0x7a) || fileName[i] == ' ') {            continue;        }        return false;    }    return true;}/** * see if this file is directory * @param attribute * @return */bool isDirectory(int attribute) {    if (attribute & 0x10) {        return true;    }    return false;}/** * get FAT entry value * @param file * @param dataClusterIndex * @return FAT entry value */int getFATEntryValue(FILE *file, int dataClusterIndex) {    long FATBeginIndex = bootReservedSectors * bytesPerSector;    u16 value = 0;    u16 *valuePtr = &value;    //If n is even, then the physical location of the entry is the low four bits in location 1+(3*n)/2    //and the 8 bits in location (3*n)/2    //result : 8 bits in 1+(3*n)/2 as high 8 bits ;  high 4 bits in (3*n)/2 as low 4 bits    FATBeginIndex += (3 * dataClusterIndex) / 2;    fseek(file, FATBeginIndex, SEEK_SET);    fread(valuePtr, 1, 2, file);    //little endian    //(3*n)/2 is stored in low 8 bits ,  1+(3*n)/2 is stored in high 8 bits    if (dataClusterIndex % 2 == 0) {        value = value >> 4;    } else {        //If n is odd, then the physical location of the entry is the high four bits in location (3*n)/2 and        //the 8 bits in location 1+(3*n)/2        //result : low 4 bits in 1+(3*n)/2 as high 4 bits ; 8 bits in (3*n)/2 as low 8 bits        value = value & 0x0FFF;    }    return value;}/** * read file content * @param file * @param firstLogicalCluster * @return */char *readFile(FILE *file, int firstLogicalCluster) {    int currBeginIndex = getBeginIndexOfCluster(firstLogicalCluster);    char *content = (char *) malloc(sectorsPerCluster * bytesPerSector);    fseek(file, currBeginIndex, SEEK_SET);    fread(content, 1, sectorsPerCluster * bytesPerSector, file);    return content;}/** * parse fileName to human-style * @param fileName * @return human-style fileName */char *parseFileName(char *fileName, char *result) {    int resultIndex = 0;    bool spaceAppeared = false;    bool isDotAdded = false;    for (int i = 0; i < 11; ++i) {        if (!spaceAppeared) {            if (isupper(fileName[i])) {                result[resultIndex++] = tolower(fileName[i]);            } else if (isdigit(fileName[i])) {                result[resultIndex++] = fileName[i];            } else if (fileName[i] == ' ') {                spaceAppeared = true;            }        } else {            if (isupper(fileName[i])) {                if (!isDotAdded) {                    result[resultIndex++] = '.';                    isDotAdded = true;                }                result[resultIndex++] = tolower(fileName[i]);            } else if (isdigit(fileName[i])) {                result[resultIndex++] = fileName[i];            }        }    }    result[resultIndex] = '\0';}/** * get the part of before the first '/' * w/ --> w * * @param fileName * @return */char *getParentFilePath(char *fileName) {    char *result = (char *) malloc(strlen(fileName));    int i = 0;    for (i = 0; fileName[i] != '/' && fileName[i] != '\0'; ++i) {        result[i] = fileName[i];    }    result[i + 1] = '\0';    return result;}/** * get the part of after the first '/' * w/2.txt --> 2.txt * @param fileName * @return */char *getChildFilePath(char *fileName) {    char *result = (char *) malloc(strlen(fileName));    int i = 0;    while (fileName[i] != '/') {        i++;    }    strcpy(result, fileName + i + 1);    result[strlen(fileName) - i - 1] = '\0';    if (strlen(result) == 0) {        return NULL;    }    return result;}/** * get begin bytes of specific cluster index * @param firstLogicalCluster * @return */long getBeginIndexOfCluster(int firstLogicalCluster) {    long bootAndFATLength =            (bootReservedSectors + FATs * sectorsPerFAT) * bytesPerSector;    //ceil to sectors multiple    long rootDirectoryLength =            ((maxRootDirEntries * DIRECTORY_ENTRY_SIZE + bytesPerSector - 1) / bytesPerSector) * bytesPerSector;    long dataAreaBeginIndex = bootAndFATLength + rootDirectoryLength;    // cluster offset which cluster index = 2(first)    return dataAreaBeginIndex + (firstLogicalCluster - 2) * sectorsPerCluster * bytesPerSector;}const int ALL_EMPTY_ENTRIES = -2;const int NO_FILE_ENTRY = -1;const int NORMAL = 0;/** * process one directory entry * @param file * @param directoryEntryPtr * @return */intprintDirectoryEntry(FILE *file, struct DirectoryEntry *directoryEntryPtr, char *directoryName, char *targetFileName) {    fread(directoryEntryPtr, 1, DIRECTORY_ENTRY_SIZE, file);    //if the rest of root directory entries are all empty,then stop loop    if (directoryEntryPtr->fileName[0] == '\0') {        return ALL_EMPTY_ENTRIES;    }    //if fileName[0] == 0xE5 ,then this entry is empty    //empty entry will be ignored    if (directoryEntryPtr->fileName[0] == 0xe5) {        return NO_FILE_ENTRY;    }    //if fileName contains illegal characters , then skip current entry    if (!isIllegalFileName(directoryEntryPtr->fileName)) {        return NO_FILE_ENTRY;    }    char *realFileName = (char *) malloc(strlen(directoryName) + 12);//human prefer this style of fileName    strcpy(realFileName, directoryName);    if (strlen(directoryName) != 0) {        realFileName[strlen(realFileName)] = '/';    }    char *currFileName = realFileName + strlen(realFileName);    if (isDirectory(directoryEntryPtr->attribute)) {        //process directory        parseFileName(directoryEntryPtr->fileName, currFileName);        if (targetFileName != NULL && strcmp(currFileName, getParentFilePath(targetFileName)) != 0) {            return NO_FILE_ENTRY;        }        if (!traverseSubDirectory(file, realFileName, directoryEntryPtr->firstLogicalCluster,                                  targetFileName == NULL ? NULL : getChildFilePath(targetFileName))) {            if (targetFileName == NULL) {                print(DIR_COLOR,realFileName);                print(DIR_COLOR,"\n");            }            return NO_FILE_ENTRY;        } else {            return NORMAL;        }    } else {        //process file        parseFileName(directoryEntryPtr->fileName, currFileName);        if (targetFileName == NULL) {            print(FILE_COLOR,realFileName);            print(FILE_COLOR,"\n");            return NORMAL;        }        if (strcmp(currFileName, targetFileName) == 0) {            char *content = readFile(file, directoryEntryPtr->firstLogicalCluster);            print(FILE_COLOR,content);            print(FILE_COLOR,"\n");            free(content);            return NORMAL;        }    }    return NO_FILE_ENTRY;}/** * * @param file * @param directoryName * @param firstLogicalCluster * @return if subDirectory is not empty ,return true  ; else return false */bool traverseSubDirectory(FILE *file, char *directoryName, int firstLogicalCluster, char *targetFileName) {    int currBeginIndex = getBeginIndexOfCluster(firstLogicalCluster);    struct DirectoryEntry directoryEntry;    struct DirectoryEntry *directoryEntryPtr = &directoryEntry;    bool hasFile = false;    //process one entry in each iteration    for (int i = 0; i < sectorsPerCluster * DIRECTORY_ENTRY_NUMBER_PER_SECTOR; ++i) {        fseek(file, currBeginIndex, SEEK_SET);        currBeginIndex += DIRECTORY_ENTRY_SIZE;        int result = printDirectoryEntry(file, directoryEntryPtr, directoryName, targetFileName);        if (result == NORMAL) {            hasFile = true;        } else if (result == ALL_EMPTY_ENTRIES) {            break;        }    }    return hasFile;}/** * traverse the root directory entries * @param file * @param directoryEntryPtr */void traverseRootDirectory(FILE *file, struct DirectoryEntry *directoryEntryPtr, char *targetFileName) {    //sectors  = sectors of boot sector + FATSize * sectorsPerFAT    long beginIndex = (bootReservedSectors + FATs * sectorsPerFAT) * bytesPerSector;    bool hasFile = false;    for (int i = 0; i < maxRootDirEntries; ++i) {        fseek(file, beginIndex, SEEK_SET);        beginIndex += DIRECTORY_ENTRY_SIZE;        int result = printDirectoryEntry(file, directoryEntryPtr, "", targetFileName);        if (result == NORMAL) {            hasFile = true;        } else if (result == ALL_EMPTY_ENTRIES) {            break;        }    }    if (!hasFile) {        print(NORMAL_COLOR,"unknown path\n");    }}//Function 3//************************************************************************************************************************************const int NOT_FOUND = -1;/** * find the cluster index of targetDirectoryPath * @param file * @param directoryEntryPtr * @param targetFileName * @return */int searchDirectoryEntry(FILE *file, struct DirectoryEntry *directoryEntryPtr, char *targetFileName) {    fread(directoryEntryPtr, 1, DIRECTORY_ENTRY_SIZE, file);    if (directoryEntryPtr->fileName[0] == '\0') {        return NOT_FOUND;    }    if (directoryEntryPtr->fileName[0] == 0xe5) {        return NOT_FOUND;    }    if (!isIllegalFileName(directoryEntryPtr->fileName)) {        return NOT_FOUND;    }    char currFileName[12];    if (isDirectory(directoryEntryPtr->attribute)) {        parseFileName(directoryEntryPtr->fileName, currFileName);        if (strcmp(currFileName, getParentFilePath(targetFileName)) != 0) {            return NOT_FOUND;        }        //if matches currFileName == getParentFilePath(targetFileName)        char *childFilePath = getChildFilePath(targetFileName);        if (childFilePath == NULL) {            //if found,then return currentLogicalCluster            return directoryEntryPtr->firstLogicalCluster;        }        int result = searchSubDirectory(file, directoryEntryPtr->firstLogicalCluster,                                        getChildFilePath(targetFileName));        if (result == NOT_FOUND) {            return NOT_FOUND;        } else {            return result;        }    }    return NOT_FOUND;}/** * find the cluster index of targetDirectoryPath * @param file * @param firstLogicalCluster * @param targetFileName * @return */int searchSubDirectory(FILE *file, int firstLogicalCluster, char *targetFileName) {    int currBeginIndex = getBeginIndexOfCluster(firstLogicalCluster);    struct DirectoryEntry directoryEntry;    struct DirectoryEntry *directoryEntryPtr = &directoryEntry;    //process one entry in each iteration    for (int i = 0; i < sectorsPerCluster * DIRECTORY_ENTRY_NUMBER_PER_SECTOR; ++i) {        fseek(file, currBeginIndex, SEEK_SET);        currBeginIndex += DIRECTORY_ENTRY_SIZE;        int result = searchDirectoryEntry(file, directoryEntryPtr, targetFileName);        if (result != NOT_FOUND) {            return result;        }    }    return NOT_FOUND;}//**************************************************************************************************************************const int FILE_FOUND = 2;const int DIR_FOUND = 1;const int NONE = 0;/** * count one directory entry * @param file * @param directoryEntryPtr * @return */int countDirectoryEntry(FILE *file, struct DirectoryEntry *directoryEntryPtr) {    fread(directoryEntryPtr, 1, DIRECTORY_ENTRY_SIZE, file);    if (directoryEntryPtr->fileName[0] == '\0') {        return ALL_EMPTY_ENTRIES;    }    if (directoryEntryPtr->fileName[0] == 0xe5) {        return NONE;    }    if (!isIllegalFileName(directoryEntryPtr->fileName)) {        return NONE;    }    if (isDirectory(directoryEntryPtr->attribute)) {        //process directory        return DIR_FOUND;    } else {        //process file        return FILE_FOUND;    }}/** * print the indent of each line * @param indent */void printIndent(int indent) {    for (int i = 0; i < 4 * indent; ++i) {        print(NORMAL_COLOR," ");    }}/** * * @param file * @param parentDirName * @param firstLogicalCluster * @param targetFileName * @return */int countSubDirectory(FILE *file, int firstLogicalCluster, struct Stack *stackPtr, char *parentDirName) {    long currBeginIndex = 0;    struct DirectoryEntry directoryEntry;    struct DirectoryEntry *directoryEntryPtr = &directoryEntry;    int fileNum = 0;    int dirNum = 0;    char dirName[120];    char number[10];    int indent = 0;    strcpy(dirName, parentDirName);    while (true) {        currBeginIndex = getBeginIndexOfCluster(firstLogicalCluster);        fileNum = 0;        dirNum = 0;        //process one entry in each iteration        for (int i = 0; i < sectorsPerCluster * DIRECTORY_ENTRY_NUMBER_PER_SECTOR; ++i) {            fseek(file, currBeginIndex, SEEK_SET);            currBeginIndex += DIRECTORY_ENTRY_SIZE;            int result = countDirectoryEntry(file, directoryEntryPtr);            if (result == FILE_FOUND) {                fileNum++;            } else if (result == DIR_FOUND) {                dirNum++;                struct ClusterInfo info;                info.clusterIndex = directoryEntryPtr->firstLogicalCluster;                info.level = indent + 1;                parseFileName(directoryEntryPtr->fileName, info.fileName);                push(stackPtr, info);            } else if (result == ALL_EMPTY_ENTRIES) {                break;            }        }        printIndent(indent);        print(NORMAL_COLOR,dirName);        print(NORMAL_COLOR,": ");        printNumber(NORMAL_COLOR,fileNum);        print(NORMAL_COLOR," files,");        printNumber(NORMAL_COLOR,dirName);        print(NORMAL_COLOR," directories\n");        if (isEmpty(stackPtr)) {            break;        } else {            struct ClusterInfo info = pop(stackPtr);            firstLogicalCluster = info.clusterIndex;            indent = info.level;            strcpy(dirName, strcat(info.fileName, "/"));        }    }}/** * count how many files and directories of current directory,not including descendant files or directories * @param file * @param directoryEntryPtr * @param targetFileName */void countRootDirectory(FILE *file, struct DirectoryEntry *directoryEntryPtr, char *targetFileName) {    long beginIndex = (bootReservedSectors + FATs * sectorsPerFAT) * bytesPerSector;    bool isFound = false;    struct Stack stack;    struct Stack *stackPtr = &stack;    initStack(stackPtr);    for (int i = 0; i < maxRootDirEntries; ++i) {        fseek(file, beginIndex, SEEK_SET);        beginIndex += DIRECTORY_ENTRY_SIZE;        int result = searchDirectoryEntry(file, directoryEntryPtr, targetFileName);        if (result != NOT_FOUND) {            //count this entry and its sub directories and files            isFound = true;            countSubDirectory(file, result, stackPtr, targetFileName);            break;        }    }    if (!isFound) {        strcat(targetFileName,": 0 files, 0 directories\n");        print(NORMAL_COLOR,targetFileName);    }}//****************************************************************************************************************************/** * see if this file is a file * @param fileName * @return */bool isFile(char *fileName) {    for (int i = 0; i < strlen(fileName); ++i) {        if (fileName[i] == '.') {            return true;        }    }    return false;}/** * remove content which before the first space * @param fileName */void getDirName(char *fileName) {    int i = 0;    while (fileName[i] != ' ') {        i++;    }    i++;    int j = 0;    while (fileName[i] != '\0') {        fileName[j++] = fileName[i++];    }    fileName[j] = '\0';}//**********************************************************************************************************************/** * Main Function * @param FAT12fileName */void readFAT12(char *FAT12fileName) {    struct BootSector bootSector;    struct BootSector *bootSectorPtr = &bootSector;    FILE *file = fopen(FAT12fileName, "rb");    readBootSector(file, bootSectorPtr);    initGlobalVariable(bootSectorPtr);    struct DirectoryEntry rootEntry;    struct DirectoryEntry *rootEntryPtr = &rootEntry;    traverseRootDirectory(file, rootEntryPtr, NULL);    print(NORMAL_COLOR,"\nPlease choose function 2 or function 3:");    int function = 0;    scanf("%d", &function);    getchar();    char fileName[100];    if (function == 2) {        while (true) {            scanf("%s", fileName);            if (strcmp(fileName, "quit") == 0) {                return;            }            traverseRootDirectory(file, rootEntryPtr, fileName);        }    } else if (function == 3) {        while (true) {            gets(fileName);            if (strcmp(fileName, "quit") == 0) {                return;            }            getDirName(fileName);            if (isFile(fileName)) {                print(NORMAL_COLOR,"Not a directory!\n");            } else if (fileName[strlen(fileName) - 1] != '/') {                print(NORMAL_COLOR,"Directory should be ended with '/'\n");            } else {                countRootDirectory(file, rootEntryPtr, fileName);            }        }    } else {        print(NORMAL_COLOR,"Error\n");    }}int main() {    readFAT12("/home/sinjinsong/a.img");    return 0;}